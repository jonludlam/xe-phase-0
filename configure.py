#!/usr/bin/env python

import sys
import os.path
from string import maketrans
from subprocess import call

CONFIG = "./fetch.conf"
SPECSDIR = "./SPECS"
SOURCESDIR = "./SOURCES"

number_skipped = 0
number_fetched = 0


def parse_config():
    """Returns list of tuples (spec, url, override) from active config lines"""
    f = open(CONFIG, "r")
    lines = map(lambda l: l.strip(), f.readlines())
    f.close()
    # ignore empty lines and comments
    lines = filter(lambda l: l and not l.startswith('#'), lines)
    # split into tuples and return
    return map(lambda l: l.split(','), lines)


def fetch_source(spec, url, override):
    global number_skipped, number_fetched

    # check the .spec file exists
    if not(os.path.exists(spec)):
        print "%s doesn't exist" % spec
        sys.exit(1)

    final_name = url.split("/")[-1]
    if override != "":
        final_name = override
    final_path = os.path.join(SOURCESDIR, final_name)
    if os.path.exists(final_path):
        number_skipped += 1
    else:
        print "fetching %s -> %s" % (url, final_path)
        call(["curl", "-k", "-L", "-o", final_path, url])
        number_fetched += 1


def target_deps_from_spec(spec_file):
    deps = []
    f = open(spec_file, 'r')
    for line in f:
        if "Name:" in line:
            target = line.split("Name:")[1].strip()
        if "BuildRequires:" in line:
            requires = line.split("BuildRequires:")[1]
            requires = requires.translate(maketrans(',', ' '))
            requires = requires.split()
            requires = map(lambda r: r.strip(), requires)
            requires = map(lambda r: r.split("-devel")[0], requires)
            deps += requires
    f.close()
    return (target, deps)


def strip_external_deps(t_d_map):
    """
    Given map M of target to deps, for each t in M, remove all
    dependencies, d, from t for which there is no target in M.
    """
    for t in t_d_map:
        t_d_map[t][:] = [d for d in t_d_map[t] if d in t_d_map]


def makefile_snippet_from_dep_map(target_deps_map):
    """
    Returns a list of lines (ready to write to Makefile) of the targets and
    their dependencies with an 'all:' target that contains all other targets at
    the top
    """
    lines = ['# Begin autogenerated targets\n']
    # target to build everything (SRPMs and all RPMs)
    lines.append('build: srpms %s\n' % ' '.join(map(lambda s: '_' + s, target_deps_map.keys())))
    # target to build all SRPMs
    lines.append('\nsrpms:\n')
    for t in target_deps_map:
        lines.append('\t$(RPMBUILD) --nodeps -bs $(RPM_SPECSDIR)/%s.spec\n' % t)
    # target to build and install each RPM (with dependencies)
    for t in target_deps_map:
        lines.append('\n_%s: %s\n' % (t, ' '.join(map(lambda s: '_' + s, target_deps_map[t]))))
        lines.append('\t$(RPMBUILD) --target $(DOMAIN0_ARCH_OPTIMIZED) -bb $(RPM_SPECSDIR)/%s.spec\n' % t)
        lines.append('\t$(RPM) -ivh $(RPM_BINDIR)/%s*.rpm || echo %s is already installed\n' % (t, t))
    lines.append('# End autogenerated targets\n')
    return lines


def specs_to_makefile(all_specs, makefile_path):
    """
    Given a list of spec files that may have some interdependence, create
    a Makefile that builds them (and installs them) in the order required.
    Note, external dependencies are still expected to be installed.

    E.g. Given the following spec files with their dependencies:
        * pkg1 (only external dependencies or none)
        * pkg2 (depends on pkg1)
        * pkg3 (depends on both pkg1 and pkg2)
    build a Makefile with targets that build and install the RPMs for each pkgN
    with their dependencies listed so make can resolve.
    """
    target_deps_map = {}
    for spec in all_specs:
        print "Extracing build dependencies from %s" % spec
        target, deps = target_deps_from_spec(spec)
        target_deps_map[target] = deps
    print "Build dependency graph complete: %s" % target_deps_map
    print "Stripping out external dependencies..."
    strip_external_deps(target_deps_map)
    print "Reduced dependency graph: %s" % target_deps_map

    print "Generating: %s" % makefile_path
    f = open(makefile_path, 'w')
    f.writelines(makefile_snippet_from_dep_map(target_deps_map))


if __name__ == "__main__":
    config = parse_config()

    for (spec, url, override) in config:
        spec_path = os.path.join(SPECSDIR, spec)
        fetch_source(spec_path, url, override)
    print "number of packages skipped: %d" % number_skipped
    print "number of packages fetched: %d" % number_fetched

    # Create targets to be included in Makefile
    all_specs = [line[0] for line in config]
    all_specs = map(lambda spec: os.path.join(SPECSDIR, spec), all_specs)
    specs_to_makefile(all_specs, './targets.mk')
